# گزارش آزمایش اول آز مهندسی نرم‌افزار


پرسش‌ها:

1. 
این پوشه حاوی تمام اطلاعات لازم برای مدیریت نسخه‌های مختلف پروژه است و شامل اطلاعاتی مانند تاریخچه تغییرات، پیکربندی‌ها و داده‌های مربوط به شاخه‌ها و برچسب‌ها می‌شود.
اطلاعات ذخیره شده در آن شامل: ۱. تاریخچه تغییرات ۲. آبجکت‌ها ۳. شاخه‌ها ۴. برچسب‌ها ۵. کانفیگ‌ها

با دستور git init این پوشه ساخته می‌شود.

2.
منظور از atomic بودن در atomic commit و atomic pull-request این است که هر عمل به صورت یک واحد کامل و یکپارچه انجام شود که یا به طور کامل موفق شود یا به طور کامل شکست بخورد، بدون اینکه حالت ناتمامی در سیستم باقی بگذارد. این ویژگی تضمین می‌کند که هیچ‌گونه تغییر ناقصی در سیستم ایجاد نشود و همه عملیات به طور کامل و بی‌نقص اعمال شوند.

بصورت خلاصه می‌توان atomic بودن را اینطوری توصیف کرد:
همه یا هیچ: یا تمامی تغییرات اعمال شده در pull-request,commit به طور کامل انجام می‌شود یا هیچ‌کدام از آن‌ها اعمال نمی‌شود.
Consistency: بعد از انجام commit,pull-request، مخزن باید در یک وضعیت ثابت و سازگار باقی بماند.
Rollback: اگر به هر دلیلی commit, pull-request موفق نشود، تمامی تغییرات به حالت قبل بازگردانده می‌شوند، بدون اینکه تغییری در تاریخچه پروژه ایجاد شود.

3.
دستور fetch تغییرات جدید را از مخزن remote دریافت می‌کند. اما آن‌ها را به مخزن محلی منتقل نمی‌کند. بعدا می‌توان تصمیم گرفت که این تغییرات با rebase یا merge اعمال شود یا نه
دستور merge دو شاخه مختلف را با هم ادغام می‌کند تغییرات از شاخه دیگر به شاخه فعلی اضافه می‌شود و یک commit جدید اضافه می‌شود که نشان دهنده ترکیب این دو شاخه است.
دستور pull ترکیبی از دستورات fetch و merge است که تغییرات را از مخزن remote دریافت می‌کند و در مخزن محلی اعمال می‌کند
دستور rebase تغییرات شاخه‌ی فعلی را به بالای یک شاخه دیگر منتقل می‌کند. این دستور تاریخچه گیت را تمیزتر نگه می‌دارد ولی در صورت بروز conflict مشکلاتی ایجاد می‌کند.
دستور cherry-pick برای انتقال commit های خاصی از یک شاخه به شاخه دیگر است این روش برای انتخاب و اعمال تغییرات خاص بدون نیاز به ترکیب کامل شاخه‌ها مفید است.

4.
دستور reset برای برگرداندن تغییرات استفاده می‌شود که سه حالت soft و hard و mixed دارد که هرکدام تغییر متفاوتی روی شاخه، ایندکس و دایرکتوری دارند.

دستور revert یک commit جدید ایجاد می‌کند که تغییرات commit قبلی را برمی‌گرداند این دستور تاریخچه پروژه را تغییر نمی‌دهد

دستور restore برای بازگرداندن فایل‌ها به حالت قبلی استفاده می‌شود. می‌تواند تغییرات در working directory و  ایندکس را برگرداند.

دستور switch برای جا به جایی بین شاخه‌های مختلف استفاده می‌شود. از آن به عنوان جایگزینی برای checkout استفاده می‌شود.

دستور checkout کاربردهای متنوعی دارد از آن می‌توان برای جابه‌جایی بین شاخه‌ها و بازگرداندن فایل‌ها استفاده کرد

5.
در git مفهوم stage یا index به مرحله‌ای اشاره دارد که تغییرات فایل‌ها قبل از commit شدن در آن قرار می‌گیرند. به عبارت دیگر، وقتی شما تغییراتی در فایل‌های پروژه خود ایجاد می‌کنید و آن‌ها را با دستور `git add` به stage اضافه می‌کنید، این تغییرات در index ذخیره می‌شوند تا در commit بعدی به مخزن اضافه شوند.

دستور git stash برای ذخیره موقت تغییرات استفاده می‌شود. فرض کنید در حال کار روی یک ویژگی جدید هستید و تغییراتی در فایل‌ها ایجاد کرده‌اید، اما هنوز آماده commit کردن نیستید و نیاز دارید به یک شاخه دیگر بروید یا تغییرات دیگری را اعمال کنید. در این حالت، می‌توانید با استفاده از `git stash` تغییرات فعلی را ذخیره کنید و به حالت قبلی بازگردید. بعداً می‌توانید این تغییرات را با دستور `git stash apply` یا `git stash pop` دوباره اعمال کنید.

6.
در git مفهوم snapshot به معنای ثبت وضعیت فایل‌ها در یک لحظه خاص از زمان است. هر بار که شما یک commit انجام می‌دهید، Git یک snapshot از کل پروژه شما می‌گیرد. این snapshot شامل وضعیت تمام فایل‌ها و دایرکتوری‌ها در آن لحظه است

ارتباط snapshot با commit این است که هر commit در واقع یک snapshot از پروژه شما است. به عبارت دیگر، هر commit یک نقطه بازیابی (restore point) است که می‌توانید به آن بازگردید. این روش به شما امکان می‌دهد تا به نسخه‌های قبلی بازگردید

7.
در Git، دو نوع مخزن (repository) وجود داردlocal repositoy و remote repository. هر کدام از این مخازن کاربردها و ویژگی‌های خاص خود را دارند.
مخزن محلی:

   - تمام تغییرات و commit‌ها ابتدا در این مخزن ذخیره می‌شوند.
   - می‌توان بدون نیاز به اتصال به اینترنت، تغییرات را در این مخزن انجام داد و commit کرد.
مخزن remote:

   - این مخزن بر روی یک سرور یا پلتفرم میزبانی مانند GitHub، GitLab یا Bitbucket قرار دارد.
   - این مخزن به اشتراک گذاشته می‌شود و اعضای تیم می‌توانند به آن دسترسی داشته باشند و تغییرات خود را push کنند.
   - برای همگام‌سازی تغییرات بین مخازن محلی و راه دور، از دستورات `git push` و `git pull` استفاده می‌شود



# گزارش مراحل آزمایش

## کلیات
در این آزمایش یک اپلیکیشن ساده static frontend که به کمک فریمورک flask که برای زبان پایتون است توسعه داده شده است. در بخش زیر تصویر frontend و نحوه‌ی اجرای نرم افزار از طریق ترمینال را مشاهده می‌کنید. برنامه روی localhost و پورت 5000 بالا آمده است و توسط سرور فلاسک سرو می‌شود.

![image](https://github.com/user-attachments/assets/bd92abc4-8b5b-4c34-9aea-ac7377880fde)

![image](https://github.com/user-attachments/assets/d3ac845e-42b8-4704-aa08-855033f00e17)

## اهداف آژمایش

برنچ main به صورت protected قرار داده شده است طوری که برای مرج شدن کد ابتدا توسعه‌دهنده باید روی یک برنچ دیگر کار توسعه را انجام دهد و سپس یک pull request بسازد. سپس این pull request توسط سایر اعضای تیم (میتوان روی این هم محدودیت گذاشت که از حوصله ازمایش ما خارج است) باید اپرو شود تا امکان مرج داشته باشد. تصویر زیر مثال همین موضوع است که اجازه مرج به پول ریکوست داده نشده است چرا که اپرو کسی را ندارد.
![image](https://github.com/user-attachments/assets/cdf6fdf2-318f-485c-96a6-03bd1116cb9f)

همچنین تصویر زیر مثال مرج شده یک pull request است که در تصویر هم مشخص است که این مرج ریکوست اپرو گرفته است و بعد مرج شده است.

![image](https://github.com/user-attachments/assets/142dfce8-a6e3-470d-ad30-b7acc41be112)

مسئله بعدی تعداد کامیت‌هاست که در شرح ازمایش نیز مطرح شده است. برنچ main پروژه در حال حاضر ۲۳ کامیت دارد که معنادار هستند. دو تصویر زیر نشان‌دهنده‌ی تعداد و پیام مربوط به کامیت‌ها میباشد.

![image](https://github.com/user-attachments/assets/3c343898-41b2-4cf3-ba94-b768cffeb976)

![image](https://github.com/user-attachments/assets/bc52a603-984a-4056-9536-92d8ec033eee)

در نامگذاری برنچ‌ها تلاش شده تا برای برنچ‌هایی که نقش توسعه دارند از پیشوند feture استفاده شود. همچنین تریگر نمونه جاب مربوط به CI/CD نیز روی پوش روی این برنچ‌ها بعلاوه برنچ main قرار داده شده است به این معنا که با هر بار پوش روی این برنچ‌ها و یا برنچ main جاب تریگر میشود. مسائل مربوط به CI/CD و پایپلاین در ادامه توضیح داده خواهد شد. تصویر زیر نمونه نامگذاری برنچ‌ها در پروژه می‌باشد. همچنین تلاش شده تا از ویژگی branching به نحو احسن در پروژه استفاده شود و از سه برنچ اصلی فیچر و یک برنچ main و تعدادی برنچ دیگر استفاده شده است.
![image](https://github.com/user-attachments/assets/757df857-5653-4770-831d-82eddb0f974a)



تنها مسیر قرار گرفتن کد روی برنچ main که برنچ اصلی پروژه میباشد فرایند pull request --> approve (review) --> merge میباشد. در تصویر زیر فهرست pull requestهای بسته شده پروژه دیده میشود.
![image](https://github.com/user-attachments/assets/b17ddba4-9b9e-4ac9-953e-32ced860a593)




